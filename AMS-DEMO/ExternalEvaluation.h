#ifndef EXTERNALEVALUATION_H_INCLUDED
#define EXTERNALEVALUATION_H_INCLUDED


#include <stdexcept>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include "TypeWrapper.h"
#include <limits>



template<class In>
struct DummyNormalization {inline void normalize(In&) const {}};


/// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/// 
/// 
template<class In, class Out, class Param, class Norm = DummyNormalization<In> >
struct ExternalEvaluation : public Norm {
	// simulator's (external process) input is optimizer's (this program) output and
	// vice-versa
	std::string inFname, outFname;
	std::string homeDir, executableCommand;
	typedef Out Value;
	typedef In Input;
	enum {geneBounds = false};
	
	void operator() (const Input& solution, Value& result, double& violation, Param& parameters) const {
		writeIn(solution);
		int outRes = system( (executableCommand + " " + homeDir).c_str());
		if (outRes != 0)
			throw std::runtime_error(std::string("Failed to run ")+executableCommand + " " + homeDir);
//		std::cout << (executableCommand + " " + homeDir) << "\n";
		readOut(result, violation, parameters);
	}
	
	// void normalize(Input& in) const is inherited from class Norm
	
	void writeIn(const Input& solution) const {
        std::string fileName = (homeDir != "" ? (homeDir + "/" + inFname) : inFname);
		std::ofstream file(fileName.c_str());
		if (file) {
			file << "# file generated by ExternalEvaluation class\n";
			for (size_t i = 0; i < solution.size(); ++i)
				file << solution[i] << "\n";
		}
		if (!file) 
			throw std::runtime_error("ExternalEvaluation: writing to file "+fileName+" failed");
	}
	
	template<class Value>
	void readOut(Value& out, double& violation, Param& parameters) const {
		std::ifstream file((homeDir != "" ? (homeDir + "/" + outFname).c_str() : outFname.c_str()));
		
		violation = 0.0;
		for (size_t i = 0; i < TypeWrapper::size(out) + TypeWrapper::size(parameters); ) {
			if (file.peek() == '#') {
				file.ignore(1);
				std::string line;
				std::getline(file, line);
				std::istringstream lineStream(line);
				std::string comment;
				lineStream >> comment;
				if (comment == "violation") {
					lineStream >> violation;
				}
			} else  {
				if (!file) {
					violation = std::numeric_limits<double>::infinity();
					// throw std::runtime_error("ExternalEvaluation: error while reading file");
					if (i < TypeWrapper::size(out))
						out[i] = std::numeric_limits<double>::infinity();
					else
						parameters[i - TypeWrapper::size(out)] = std::numeric_limits<double>::infinity();
				} else {				
					if (i < TypeWrapper::size(out))
						file >> out[i];
					else
						file >> parameters[i - TypeWrapper::size(out)];
				}
				++i;
			}
		}
	}
};


#endif // EXTERNALEVALUATION_H_INCLUDED
